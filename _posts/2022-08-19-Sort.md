---
layout: post
title: Wer nicht sortiert der länger sucht
excerpt_separator: <!--more-->
---

Im zweiten Teil meiner Serie: "Die Schönheit der Algorithmen und Datenstrukturen" will ich zeigen, wie man mit verschiedenen Algorithmen Karten sortieren kann. Auch will ich zeigen, wie und warum diese Algorithmen, obwohl das Ergebnis das selbe ist, völlig verschieden sind.
<!--more-->
<br/><br/>
*Achtung: Wie in den anderen Teilen der Serie werde ich auch hier in einigen Teilen stark vereinfachen. Dieser Text soll vor allem neugierig machen und nicht terminologisch 100% korrekt sein.*

## Lass uns ein Spiel spielen
Lass uns mal ein neues Spiel erfinden. Jeder Spieler bekommt dafür 10 Karten. Diese Karten haben jeweils eine Zahl von 1-100 drauf. Die Karten liegen dabei verdeckt vor einem auf dem Tisch. 
Das Ziel des Spieles ist es, seine Karten zu sortieren, und dabei so wenig Züge wie möglich zu benötigen. Ein Zug entspricht dem Ansehen oder dem Bewegen einer Karte.
Wer seine Karten sortiert hat und dabei am wenigsten Züge gemacht hat, gewinnt.\
Die Frage die man sich nun als Spieler stellt: *Wie sortiere ich meine Karten so effizient wie möglich?*
<br/><br/>
Dieses Spiel scheint zwar sehr gestellt (ist es ja auch) aber dennoch bildet es eine sehr häufige und komplexe Problemstellung in unserer digitalen Welt ab. Eine Google-Suche würde zum Beispiel ewig dauern, wenn jede einzelne Webseite erst durchsucht werden müsste, nachdem du den Suchbegriff eingegeben hast. Die Stichwörter die man eingibt hat Google bereits sortiert in einer Liste liegen
und kann ein Ergebnis deshalb schneller liefer, als wenn die ganze Liste erst durchsucht werden müsste.\
Das selbe Problem gibt es auch in der analogen Welt. Stell dir mal ein Telefonbuch vor, welches keine Sortierung hat. Da wäre das Telefon schnell ausgestorben.
<br/><br/>

## Ein erster Ansatz
Zurück zu unserem Spiel. Stellen wir uns zunächst mal dumm und sortieren die Karten nach dem ersten Prinzip welches uns in den Sinn kommt. 
*Leg gerne mal eine kurze Lesepause ein und überlege wie du die Karten sortieren würdest.* Nun gut, am einfachsten ist es, die Kartenreihe nach der kleinsten Zahl zu durchsuchen, und diese dann
ganz links abzulegen. Danach fangen wir wieder von vorne an, aber nun suchen wir das Minimum ab der zweiten Karte. Dieses Verfahren wenden wir so lange an, bis wir bei der letzten Karte angekommen sind und so alle Karten sortiert haben. Ich habe versucht dieses Vorgehen (Algorithmus) in einer kleinen Animation darzustellen.
Ein (eindeutig) sehr primitiver Algorithmus. Er wird auch [Selection-Sort](https://de.wikipedia.org/wiki/Selectionsort) genannt.\
![SelectionSort](/images/sort/selectionSort.gif)
Wie viele Züge brauchen wir im schlechtesten Fall um die Karten zu sortieren? Nun ja, im ersten Durchgang müssen wir alle 10 Karten ansehen, im zweiten Durchgang nur noch 9, im dritten nur noch 8 usw. Also 10 + 9 + 8 ... + 1, das ergibt insgesamt 55 Züge. Lass uns das mal für einen etwas allgemeineren Fall betrachten. Nehmen wir mal an, wir haben **n** Karten (also eine beliebige Anzahl). Die Anzahl der Züge ist dementsprechend <nobr> n + (n-1) + (n-2) + ... (n-(n-1))</nobr>. Evtl. kommt dir das aus der Schule bekannt vor, dass ist die [gaußsche Summenformel](https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Summenformel). Das bedeutet für den allgemeinen Fall mit n Karten, benötigen wir $\frac{n^2 + n}{2}$ Züge um n Karten zu sortieren.

## O-Kalkühl
Ohne es zu wissen haben wir hier schon eine wichtige Analyse des Algorithmus durchgeführt. Die sogenannte *Worst-Case Analyse*. Das Ergebnis der Analyse wird oft auch im O-Kalkühl geschrieben. Das O-Kalkühl betrachtet nur das Wachstum eines Algorithmus, also wie viele Züge braucht man mehr, wenn man mehr Karten hinzufügt. Das schöne am O-Kalkühl ist, das man nur den Teil betrachtet, der das größte Wachstum ausmacht. In unserem Fall wird also $O(\frac{n^2 + n}{2})$ zu $O(n^2)$.\
Das O-Kalkühl ist ein wichtiges Werkzeug in der Informatik. Es gibt uns eine Möglichkeit, wie wir Algorithmen miteinander vergleichen können. Würden wir nun einen Algorithmus finden, der eine Worst-Case Laufzeit von $O(n)$ hätte, sollten wir natürlich diesen bevorzugen um das Spiel zu gewinnen.

## Geht es noch schneller? Ja!
Wie bereits gesagt ist der Selection-Sort Algorithmus nicht besonders schnell. Jedoch ist er sehr einfach zu verstehen.\
Ein sehr schneller Algorithmus ist das [Heap-Sort](https://de.wikipedia.org/wiki/Heapsort) Verfahren.\
Um den Heap-Sort Algorithmus zu verstehen, müssen wir uns zunächst ein paar Eigenschaften genauer ansehen und neue Begriffe klären.

## Was ist ein Heap
Ein Heap ist zuerst einmal eine Datenstruktur, also ein Gedankengebilde bzw. ein Objekt in dem Daten organisiert sind.\
Diese Datenstruktur ist wie ein Baum aufgebaut. Nun muss man wissen das wir Informatiker selten vor die Türe gehen und nur überliefert bekommen, wie Bäume auszusehen haben. Irgendwo in dieser Überlieferung muss sich wohl ein Fehler eingeschlichen haben. Bäume in der Informatik schauen nämlich so aus.
![Baum](/images/sort/tree.png){:width="250" style="display:block; margin-left:auto; margin-right:auto"}
Ich glaube man sieht das Problem ganz gut. Die Blätter sind unten und die Wurzel ist oben.\
Ein Heap sieht ähnlich aus.
![Heap](/images/sort/Heap.png){:width="250" style="display:block; margin-left:auto; margin-right:auto"}
Die Karten werden hier in einer Struktur abgebildet die dem vorherigem Baum ähnlich ist. Ganz oben, hier die 58, haben wir die Wurzel. Die Karten in der letzten Reihe 3, 35, 9 werden Blätter genannt. Die Karten liegen jedoch weiterhin in einer Reihe auf dem Tisch, also in der Reihenfolge 58, 61, 9, 3 und 35. Der Baum wird also von oben nach unten und von links und rechts gelesen.\
Der Baum der hier abgebildet ist, ist ein Binär-Baum, das heißt, dass ein Knoten (Kreis) sich immer in maximal zwei andere Knoten aufspaltet.\
Was wir nun für den Heap-Sort Algorithmus brauchen ist ein binärer Min-Heap. Ein Min-Heap hat zusätzlich die Eigenschaft, dass der Wert eines beliebigen Knotens immer kleiner ist, als alle Werte unter ihm. Das heißt gleichzeitig, dass das Minimum immer in der Wurzel steht.
![Heap-Legende](/images/sort/HeapLegend.png){:width="250" style="display:block; margin-left:auto; margin-right:auto"}
Noch kurz zu den Begrifflichkeiten, jedes Element in einem Baum (bis auf die Wurzel) ist ein Kind eines anderes Elements. Bei einem Binär-Baum hat jedes Elternteil (wie man sich bereits denken kann) maximal zwei Kinder. Die meisten Kinder (alle bis auf die Blätter) sind gleichzeitig Elternteile ihrer Kinder. 
Man kann sich das ganze also vorstellen wie ein Stammbaum einer großen Familie. Jedes Elternteil stellt zusammen mit seinen Kindern einen *Teilbaum* dar. 

## Heapify
Um aus einem beliebigen Binär-Baum einen Min-Heap zu bauen, müssen wir das *Heapify* Verfahren anwenden. Aber, wie bei fast allem im Leben, um etwas anwenden 
zu können, muss man es erst verstehen. Was ist bzw. macht also das Heapify Verfahren. Man nimmt sich für das Heapify-Verfahren immer ein Elternteil mit seinen Kindern vor (also ein Teilbaum). Zunächst wird das Minimum der beiden Kinder ermittelt. Dabei wird das kleinste Kind (also das Minimum) mit dem Elternteil verglichen. Sollte das kleinste Kind kleiner als das Elternteil sein, tauschen die beiden die Plätze. Falls Plätze getauscht worden sind, wird das Verfahren auf den nächsten Teilbaum angewendet bei dem das kleinste Kind das Elternteil ist (das nennt man nebenbei [Rekursion](https://de.wikipedia.org/wiki/Rekursion)).
Ich habe versucht das Verfahren in der folgenden Animation zu veranschaulichen.\
![Heapify](/images/sort/heapify.gif){:width="250" style="display:block; margin-left:auto; margin-right:auto"}

## Erstellen des Heaps
Um nun unsere Karten durch den Heapsort-Algorithmus sortieren zu lassen, müssen wir erst aus unserem Binär-Baum einen Min-Heap erstellen.
Dazu wenden wir das Heapify-Verfahren für jedes Elternteil des Baumes an. Also für alle Elemente bis auf die Blätter. Bei unserem Binär-Baum mit den 5 Karten müssen wir das Heapify-Verfahren also zweimal anwenden. Wichtig ist, dass das Verfahren von unten nach oben angewendet wird. Ich hoffe man kann die folgende Animation nachvollziehen. Man kann sehen, wie die kleinen Zahlen nach oben "wandern" und die großen nach unten "durchsickern".\
![MakeHeap](/images/sort/makeHeap.gif){:width="250" style="display:block; margin-left:auto; margin-right:auto"}

## Heapsort
Nachdem der Min-Heap erfolgreich von uns erstellt worden ist, kann der Heapsort angewendet werden. Da wie bereits erwähnt das kleinste Element immer die Wurzel
des Heaps ist, kann im Prinzip die Wurzel entfernt und danach der Baum "repariert" werden. Da der Baum nicht ohne Wurzel existieren kann, entfernen wir die Wurzel nicht, sondern tauschen sie gegen das letzte (am weitesten unten und am weitesten rechts) Element aus. Da nach diesem Tausch nicht mehr das kleinste Element die Wurzel bildet, muss der Heap "repariert" werden. Um den Heap zu reparieren können wir einfach das Heapify-Verfahren an der Wurzel ausführen. 
Das machen wir so lange, bis wir keine Elemente im Heap mehr haben. In der Animation kannst du sehen, wie der Heap immer kleiner wird und die Karten unten sortiert werden.\
![Heapsort](/images/sort/heapsort.gif){:width="250" style="display:block; margin-left:auto; margin-right:auto"}

## Ist das wirklich schneller?
Wenn man die Animation ein paar mal ansieht, fällt einem schon auf, dass nicht mehr jede Zahl mit jeder anderen Zahl verglichen wird, wie es bei unserem ersten Ansatz der Fall war. Das liegt daran, dass wir jetzt die Eigenschaften des Heaps ausnutzen können. Wir wissen ja, dass ein Elternteil immer kleiner als seine Kinder ist. \
Stellen wir uns mal eine beliebige Karte vor, wenn wir nun überprüfen wollen, ob diese Karte die kleinste in unserem Kartenstapel ist, reicht es aus, wenn wir nur die Wurzel unseres Heaps ansehen. Da wir ja wissen, das alle anderen Karten größer als die Wurzel sind, ist die Frage schon nach einem Vergleich beantwortet. \
Jetzt schauen wir uns den Beweis noch etwas genauer an. Wir nehmen als Hilfsmittel wieder das O-Kalkühl. Um das Heapsort-Verfahren anwenden zu können, müssen wir zunächst den Heap erstellen. Das machen wir indem wir Heapify für alle Teilbäume ausführen. Es müssen also zuerst zwei Fragen beantwortet werden. Wie "teuer" ist die Anwendung von Heapify? Wie oft muss Heapify angewandt werden besser oder besser gefragt, wie viele Teilbäume gibt es?

### Wie "teuer" ist die Anwendung von Heapify?
Lass mich zunächst noch ein mal zusammenfassen was Heapify macht.  